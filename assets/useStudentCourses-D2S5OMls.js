import{h as f,m as a,i as k,w as x,k as g,n as S,x as L,l as q,v as A,y as B,z as v,D as R,E as z,F as G,f as M,o as $,r as m,d as _,G as j}from"./index-BozJdoqh.js";import{f as H}from"./periodService-COUu7smY.js";const X=async t=>{const e=f(a,"students");await k(e,t)},Y=async t=>{const e=x(a),s=f(a,"students");t.forEach(n=>{const c=g(s);e.set(c,n)});try{await e.commit()}catch(n){throw console.error("Error committing batch:",n),new Error("Error adding students")}},Z=async()=>{const t=f(a,"students");return(await S(t)).docs.map(s=>({id:s.id,fullName:s.data().fullName,identificationNumber:s.data().identificationNumber,email:s.data().email}))},F=async t=>{try{const e=g(a,"students",t),s=await L(e);return s.exists()?{id:s.id,...s.data()}:(console.log("No such document!"),null)}catch(e){throw console.error("Error fetching student:",e),e}},ee=async t=>{const e=g(a,"students",t);await q(e)},te=async(t,e)=>{const{id:s,...n}=e,c=g(a,"students",t);await A(c,n)},se=async(t,e)=>{const s=f(a,"enrollments"),n=B(s,v("periodId","==",t),v("courseId","==",e)),h=(await S(n)).docs.map(o=>o.data().studentId).map(o=>F(o));return(await Promise.all(h)).filter(o=>o!==null)},oe=async(t,e)=>{console.log("getStudentsNotInCourse",{periodId:t,courseId:e});const s=f(a,"students"),c=(await S(s)).docs.map(r=>r.id),i=f(a,"enrollments"),h=B(i,v("periodId","==",t),v("courseId","==",e)),o=(await S(h)).docs.map(r=>r.data().studentId),y=c.filter(r=>!o.includes(r)).map(r=>F(r));return(await Promise.all(y)).filter(r=>r!==null)},U=(t,e)=>`students/${t}/periods/${e}/courses`,J=async(t,e)=>{const s=f(a,U(t,e));return(await S(s)).docs.map(c=>({id:c.id,...c.data()}))},K=async(t,e)=>{try{const{periodId:s,id:n}=e;if(console.log({studentId:t,periodId:e.periodId,courseId:e.periodCourseId}),!t)throw new Error("Student ID is null or undefined");if(!s)throw new Error("Period ID is null or undefined");if(!n)throw new Error("Period ID is null or undefined");const c=`students/${t}/periods/${e.periodId}/courses`,i=g(a,c,e.periodCourseId);await R(i,e),console.log("Course added with ID: ",e.periodCourseId);const h=f(a,"enrollments"),p=g(h);await R(p,{studentId:t,courseId:e.periodCourseId,periodId:e.periodId}),await A(i,{enrolledStudents:z(t)});const o=f(a,`periods/${e.periodId}/courses/${e.courseId}/assignments`),E=await S(o),y=f(i,"assignments"),w=x(a);E.docs.forEach(r=>{const{title:I,contributionPercentage:N}=r.data(),{grade:l,percentage:D}=r.data(),b={id:r.id,assignmentId:r.id,title:I,grade:l||0,percentage:D||0,percentageMax:Number(N)},C=g(y,r.id);w.set(C,b)}),await w.commit(),console.log("Assignments added successfully")}catch(s){throw console.error("Error adding course: ",s),new Error("Failed to add course")}},O=async(t,e,s)=>{const n=g(a,U(t,e),s);console.log({studentId:t,periodId:e,courseId:s});const c=await L(n);if(!c.exists())throw new Error("Course not found");const i=c.data();await q(n);const h=g(a,`students/${t}`);await A(h,{coursesIds:G(i.courseId)})},re=t=>{const{setIsLoading:e}=M(),[s,n]=$("selectedPeriodId",null),[c]=m.useState([]),[i,h]=m.useState([]),[p,o]=m.useState(!0),[E,y]=m.useState(null),[w,r]=m.useState([]),[I,N]=$("availablePeriods",[]),{showNotification:l}=_();m.useEffect(()=>{e(p)},[p,e]);const D=async()=>{if(I.length===0)try{o(!0);const d=await H();N(d)}catch{y("Error fetching available periods"),l("Error fetching available periods","error")}finally{o(!1)}},b=async d=>{try{if(o(!0),d){n(d);const u=await j(d);r(u)}else r([])}catch{l("Error fetching available courses","error")}finally{o(!1)}},C=async d=>{if(!s){l("Not period selected","error");return}try{o(!0);const u=await J(d,s);h(u)}catch{l("Error fetching courses","error")}finally{o(!1)}};return m.useEffect(()=>{D()},[]),m.useEffect(()=>{t&&C(t)},[t]),m.useEffect(()=>{s&&b(s)},[s]),{loading:p,error:E,courses:c,studentCourses:i,availablePeriods:I,handleAddCourse:async(d,u)=>{try{if(!s){l("Not period selected","error");return}if(console.log(i),i.filter(P=>P.id===u.periodCourseId).length>0){l("Course already added","error");return}o(!0),await K(d,u),C(d)}catch{l("Error adding course","error")}finally{o(!1)}},handleDeleteCourse:async(d,u)=>{if(!s){l("Not period selected","error");return}if(!s){l("Not period selected","error");return}try{if(!u)return;o(!0),await O(d,s,u),C(d)}catch(P){console.error(P),y("Error deleting course"),l("Error deleting course","error")}finally{o(!1)}},availableCourses:w,loadAvailableCourses:b,loadAvailablePeriods:D,setPeriodId:n}};export{F as a,X as b,Y as c,ee as d,re as e,Z as f,se as g,oe as h,te as u};
